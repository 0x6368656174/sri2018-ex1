# Задание 1 — найди ошибки

Ход мысли такой: запускаем, смотрим, что не работает, ищем, где не работает, исправляем. Я старался сразу же после
исправления делать коммит с этим исправлением, чтоб видно было как происходил процесс поиска ошибок. Никаких специальных
средств для поиска ошибок в данном проекте мне не понадобилось, хватило браузера и IDE.

В реальном проекте, скорее всего такого состояния (когда приложение вообще не запускается) не получится не у кого, 
т.к. обычно программист будет проверять то, что у него получилось либо у себя локально, либо удаленно при помощи CI.

Часть кода можно покрыть unit-тестами, например, тот же mappers.js, api.js, popup.js, отлично покроются unit-тестами.
Для остальной части кода unit-тесты нормальные написать не получится, т.к. там используется API Яндекса и Chart.js, но 
можно написать E2E-тесты, которые будут отлично работать. Но я бы этого делать не стал, т.к. приложение, объективно, 
очень простое, проверить его можно, потратив 1 минут своего времени, чтоб все протыкать, поэтому городить огород из 
E2E-тестов не разумно, хватит только легких unit-тестов для того, что можно ими покрыть.

Лично я фанат TypeScript, поэтому я бы писал приложение на нем. Но в данном случае TypeScript не помог бы найти не одной
из совершенных тут ошибок, т.к. тут проблема была с логикой и внимательностью, и типизация с ней не помогла бы.

В проекте плохо то, что отсутствуют хоть какие-то линтеры, преттиферы или что-то тому подобное. Я при исправлении
проекта старался практически не менять кодовую базу, т.к. в задание было только починить то, что не работает. 
Но дописывать что-то было бы очень неудобно, т.к. стиль в проекте как попало: где-то одинарные кавычки, где-то двойные, 
возможно что-то еще не соответствует. Лично я бы прикрутил eslint (tslint) + stylelint + prettier и вызывал бы их 
при помощи husky + lint-staged перед коммитом, что гарантировало бы единообразие кода. (Подобный сетап реализован у
меня в 3 задании).
